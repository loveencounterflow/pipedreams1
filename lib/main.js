// Generated by CoffeeScript 1.7.1
(function() {
  var CHR, COPYPASTE, ES, HELPERS, S, TEXT, TRM, TYPES, alert, badge, create_levellivestream, debug, echo, get_random_integer, help, info, log, njs_util, rainbow, rnd_from_seed, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_util = require('util');

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  CHR = require('coffeenode-chr');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);


  /* https://github.com/dominictarr/event-stream */

  ES = require('event-stream');


  /* http://stringjs.com */

  S = require('string');

  HELPERS = require('./HELPERS');


  /* https://github.com/loveencounterflow/copypaste */

  COPYPASTE = require('copypaste');


  /* https://github.com/dominictarr/level-live-stream */

  create_levellivestream = require('level-live-stream');


  /* https://github.com/dominictarr/sort-stream */

  this.$sort = require('sort-stream');

  this.create_readstream = HELPERS.create_readstream.bind(HELPERS);

  this.create_readstream_from_text = HELPERS.create_readstream_from_text.bind(HELPERS);

  this.pimp_readstream = HELPERS.pimp_readstream.bind(HELPERS);

  this.merge = ES.merge.bind(ES);

  this.$split = ES.split.bind(ES);

  this.$chain = ES.pipeline.bind(ES);

  this.through = ES.through.bind(ES);

  this.duplex = ES.duplex.bind(ES);

  this.as_readable = ES.readable.bind(ES);

  this.read_list = ES.readArray.bind(ES);

  this.eos = {
    'eos': true
  };

  this.$ = function() {
    alert('P.$ deprecated');
    throw new Error('deprecated');
  };

  this.map = function() {
    alert('P.map deprecated');
    throw new Error('deprecated');
  };

  this.resume = function(stream) {
    setImmediate(function() {
      return stream.resume();
    });
    return stream;
  };

  this.$comment = function(message, valediction) {
    var message_shown;
    message_shown = false;
    return this.remit(function(data, send, end) {
      if (!message_shown) {
        if (message != null) {
          help(message);
        }
        message_shown = true;
      }
      send(data);
      if (end != null) {
        if (valediction != null) {
          help(valediction);
        }
        return end();
      }
    });
  };

  this.$split_chrs = function(settings) {
    var decoder;
    decoder = null;
    if (settings == null) {
      settings = {};
    }
    return this.remit((function(_this) {
      return function(data, send) {
        var chr, text, _i, _len, _ref, _ref1, _results;
        if (TYPES.isa_text(data)) {
          text = data;
        } else {
          if (decoder == null) {
            decoder = new (require('string_decoder')).StringDecoder((_ref = settings['encoding']) != null ? _ref : 'utf8');
          }
          text = decoder.write(data);
        }
        _ref1 = CHR.chrs_from_text(text, settings);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          chr = _ref1[_i];
          _results.push(send(chr));
        }
        return _results;
      };
    })(this));
  };

  this.create_throughstream = function() {
    var P, R;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    R = ES.through.apply(ES, P);
    R.setMaxListeners(0);
    return R;
  };

  this.create_clipstream = function(interval_ms) {
    var R, capture, last_content;
    if (interval_ms == null) {
      interval_ms = 500;
    }
    last_content = null;
    R = this.create_throughstream();
    capture = (function(_this) {
      return function() {
        return COPYPASTE.paste(function(_, content) {
          if ((content != null) && content !== last_content && content.length > 0) {
            R.write(content);
            return last_content = content;
          }
        });
      };
    })(this);
    setInterval(capture, interval_ms);
    return R;
  };

  this.echo_clipstream = function(interval_ms) {
    return this.create_clipstream(interval_ms).pipe(this.remit((function(_this) {
      return function(text, send) {
        return echo(text);
      };
    })(this)));
  };

  this.create_levelstream = function(level_db) {
    var R;
    R = create_levellivestream(level_db);
    return R;
  };


  /*
  
  Also see https://github.com/juliangruber/multipipe
  
   * thx to http://grokbase.com/t/gg/nodejs/12bwd4zm4x/should-stream-pipe-forward-errors#20121130d5o2xbrhk3llhaxbasu5n374ke
  
  Stream = ( require 'stream' ).Stream
  Stream::pipeErr = (dest, opt) ->
    fw = dest.emit.bind(dest, "error")
    @on "error", fw
    self = this
    dest.on "unpipe", (src) ->
      dest.removeListener "error", fw  if src is self
      return
    return @pipe dest, opt
   */

  this.remit = function(method) {
    var arity, cache, get_send, on_data, on_end, send;
    send = null;
    cache = null;
    on_end = null;
    get_send = function(self) {
      var R;
      R = function(data) {
        return self.emit('data', data);
      };
      R.error = function(error) {
        return self.emit('error', error);
      };
      R.end = function() {
        return self.emit('end');
      };
      return R;
    };
    switch (arity = method.length) {
      case 2:
        on_data = function(data) {
          if (send == null) {
            send = get_send(this);
          }
          return method(data, send);
        };
        break;
      case 3:
        cache = [];
        on_data = function(data) {
          var _ref;
          if (cache.length === 0) {
            cache[0] = data;
            return;
          }
          if (send == null) {
            send = get_send(this);
          }
          _ref = [data, cache[0]], cache[0] = _ref[0], data = _ref[1];
          return method(data, send, null);
        };
        on_end = function() {
          var data, end;
          if (send == null) {
            send = get_send(this);
          }
          end = (function(_this) {
            return function() {
              return _this.emit('end');
            };
          })(this);
          if (cache.length === 0) {
            data = null;
          } else {
            data = cache[0];
            cache.length = 0;
          }
          return method(data, send, end);
        };
        break;
      default:
        throw new Error("expected a method with an arity of 2 or 3, got one with an arity of " + arity);
    }
    return ES.through(on_data, on_end);
  };

  this.$skip_empty = function() {
    return this.remit((function(_this) {
      return function(record, send) {
        if (record.length > 0) {
          return send(record);
        }
      };
    })(this));
  };


  /* TAINT rename to `$take` */


  /* TAINT end stream when limit reached */

  this.$skip_after = function(limit) {
    var count;
    if (limit == null) {
      limit = 1;
    }
    count = 0;
    return this.remit((function(_this) {
      return function(record, send) {
        count += 1;
        if (count <= limit) {
          return send(record);
        }
      };
    })(this));
  };

  this.$take = function(limit) {
    var count;
    if (limit == null) {
      limit = 1;
    }
    count = 0;
    return this.remit((function(_this) {
      return function(record, send) {
        count += 1;
        if (count <= limit) {
          return send(record);
        } else {
          return send.end();
        }
      };
    })(this));
  };

  this.$trim = function() {
    return this.remit((function(_this) {
      return function(line, send) {
        if (line != null) {
          return send(line.trim());
        }
      };
    })(this));
  };

  this.$skip_comments = function(marker) {
    if (marker == null) {
      marker = '#';
    }

    /* TAINT does only work after trimming */
    return this.remit((function(_this) {
      return function(line, send) {
        if ((line != null) && line[0] !== marker) {
          return send(line);
        }
      };
    })(this));
  };

  this.$skip_comments_2 = function() {

    /* TAINT makeshift method awaiting a better solution */
    var matcher;
    matcher = /^\s*#/;
    return this.remit((function(_this) {
      return function(line, send) {
        if ((line != null) && !matcher.test(line)) {
          return send(line);
        }
      };
    })(this));
  };

  this.$sink = function() {
    var R, sink;
    sink = (require('fs')).createWriteStream('/dev/null');
    R = this.create_throughstream().pipe(this.remit(function(data, send) {
      return send('0');
    })).pipe(sink);
    return R;
  };

  this.$sample = function(p, options) {
    var count, headers, rnd, seed, _ref, _ref1;
    if (p == null) {
      p = 0.5;
    }

    /* Given a `0 <= p <= 1`, interpret `p` as the *p*robability to *p*ick a given record and otherwise toss
    it, so that `$sample 1` will keep all records, `$sample 0` will toss all records, and
    `$sample 0.5` (the default) will toss (on average) every other record.
    
    You can pipe several `$sample()` calls, reducing the data stream to 50% with each step. If you know
    your data set has, say, 1000 records, you can cut down to a random sample of 10 by piping the result of
    calling `$sample 1 / 1000 * 10` (or, of course, `$sample 0.01`).
    
    Tests have shown that a data file with 3'722'578 records (which didn't even fit into memory when parsed)
    could be perused in a matter of seconds with `$sample 1 / 1e4`, delivering a sample of around 370
    records. Because these records are randomly selected and because the process is so immensely sped up, it
    becomes possible to develop regular data processing as well as coping strategies for data-overload
    symptoms with much more ease as compared to a situation where small but realistic data sets are not
    available or have to be produced in an ad-hoc, non-random manner.
    
    **Parsing CSV**: There is a slight complication when your data is in a CSV-like format: in that case,
    there is, with `0 < p < 1`, a certain chance that the *first* line of a file is tossed, but some
    subsequent lines are kept. If you start to transform the text line into objects with named values later in
    the pipe (which makes sense, because you will typically want to thin out largeish streams as early on as
    feasible), the first line kept will be mis-interpreted as a header line (which must come first in CSV
    files) and cause all subsequent records to become weirdly malformed. To safeguard against this, use
    `$sample p, headers: true` (JS: `$sample( p, { headers: true } )`) in your code.
    
    **Predictable Samples**: Sometimes it is important to have randomly selected data where samples are
    constant across multiple runs:
    
    * once you have seen that a certain record appears on the screen log, you are certain it will be in the
      database, so you can write a snippet to check for this specific one;
    
    * you have implemented a new feature you want to test with an arbitrary subset of your data. You're
      still tweaking some parameters and want to see how those affect output and performance. A random
      sample that is different on each run would be a problem because the number of records and the sheer
      bytecount of the data may differ from run to run, so you wouldn't be sure which effects are due to
      which causes.
    
    To obtain predictable samples, use `$sample p, seed: 1234` (with a non-zero number of your choice);
    you will then get the exact same
    sample whenever you re-run your piping application with the same stream and the same seed. An interesting
    property of the predictable sample is that—everything else being the same—a sample with a smaller `p`
    will always be a subset of a sample with a bigger `p` and vice versa.
     */
    if (!((0 <= p && p <= 1))) {
      throw new Error("expected a number between 0 and 1, got " + (rpr(p)));
    }

    /* Handle trivial edge cases faster (hopefully): */
    if (p === 1) {
      return this.remit((function(_this) {
        return function(record, send) {
          return send(record);
        };
      })(this));
    }
    if (p === 0) {
      return this.remit((function(_this) {
        return function(record, send) {
          return null;
        };
      })(this));
    }
    headers = (_ref = options != null ? options['headers'] : void 0) != null ? _ref : false;
    seed = (_ref1 = options != null ? options['seed'] : void 0) != null ? _ref1 : null;
    count = 0;
    rnd = rnd_from_seed(seed);
    return this.remit((function(_this) {
      return function(record, send) {
        count += 1;
        if ((count === 1 && headers) || rnd() < p) {
          return send(record);
        }
      };
    })(this));
  };

  this.$throttle_bytes = function(bytes_per_second) {
    var Throttle;
    Throttle = require('throttle');
    return new Throttle(bytes_per_second);
  };

  this.$throttle_items = function(items_per_second) {
    var new_gate;
    new_gate = require('floodgate');
    return new_gate({
      interval: 1 / items_per_second
    });
  };

  this.$pass = function() {
    return this.remit(function(data, send) {
      if (data != null) {
        return send(data);
      }
    });
  };

  this.$unique = function(as_key) {

    /* Given an optional `as_key` method, return a transformer that skips all repeated items in the stream.
    If `as_key` is given, it is called repeated with the stream data and expected to return an identifying
    text (or other datatypes which can be meaningfully used as an JS object key, such as an integer); which
    items to skip will be based on that key. If `as_key` is not given, then the streamed data itself is
    used as key (which, in case all the data instances strigify as `[Object object]` or similar, means that
    only the very first piece of data will make it through—probably not what you want).
     */
    var seen;
    seen = {};
    return this.remit((function(_this) {
      return function(data, send) {
        var key;
        key = as_key != null ? as_key(data) : data;
        if (seen[key] == null) {
          seen[key] = 1;
          return send(data);
        }
      };
    })(this));
  };

  this.$filter = function(filter) {

    /* Given a `filter` method, return a stream transformer that will call `r = filter data` with each data
    instance that comes down the stream and only re-send that data if `r` is strictly `true`. If `r` is
    neither strictly `true` nor strictly `false`, an error will be sent to avoid silent failure.
     */
    return this.remit((function(_this) {
      return function(data, send) {
        var r;
        switch (r = filter(data)) {
          case true:
            return send(data);
          case false:
            return null;
          default:
            return send.error(new Error("illegal filter result " + (rpr(r))));
        }
      };
    })(this));
  };

  this.$batch = function(n, handler) {

    /* TAINT check for meaningful n */

    /* TAINT make signal configurable */
    var collector, eos, on_data, on_end, received_eos;
    collector = [];
    received_eos = false;
    eos = this.eos;
    if (handler != null) {
      on_data = function(record) {
        if (record === eos) {
          received_eos = true;
        } else {
          collector.push(record);
          if (collector.length >= n) {
            handler(null, collector);
            collector = [];
          }
        }
        return this.emit('data', record);
      };
      on_end = function() {
        if (collector.length > 0) {
          handler(null, collector);
        }
        if (received_eos) {
          handler(null, eos);
        }
        return this.emit('end');
      };
    } else {
      on_data = function(record) {
        if (record === eos) {
          return received_eos = true;
        } else {
          collector.push(record);
          if (collector.length >= n) {
            this.emit('data', collector);
            return collector = [];
          }
        }
      };
      on_end = function() {
        if (collector.length > 0) {
          this.emit('data', collector);
        }
        if (received_eos) {
          this.emit('data', eos);
        }
        return this.emit('end');
      };
    }
    return ES.through(on_data, on_end);
  };

  this.$collect_sample = function(n, options, result_handler) {

    /* Given an `input_stream`, a positive integer number `n`, (facultatively) options, and a `handler`, try
    to assemble a representative sample with up to `n` records from the stream. When the stream has ended,
    the handler is called once with (a `null` error argument and) a list of records.
    
    Similarly to `PIPEDREAMS.$sample`, it is possible to pass in a `headers: true` option to make sure the
    headers line of a CSV file is not collected. Also similarly, a `seed: 1234` argument can be used to
    ensure that the sample is arbitrary but constant for the same stream and the same seed.
    
    Observe that while `$sample` does thin out the stream, `$collect_sample` will never add anything to or
    omit anything from the stream; in that respect, it is rather more similar to `$collect`.
    
    The (simple) algorithm this method uses to arrive at a representative, fixed-size sample from a collection
    of unknown size has been kindly provided by two guys on
    [Math StackExchange](http://math.stackexchange.com/q/890272/168522).
     */
    var arity, collector, headers, idx, m, on_data, on_end, p, rnd_idx, rnd_pick, seed, _ref, _ref1;
    switch (arity = arguments.length) {
      case 2:
        result_handler = options;
        headers = false;
        seed = null;
        break;
      case 3:
        headers = (_ref = options['headers']) != null ? _ref : false;
        seed = (_ref1 = options['seed']) != null ? _ref1 : null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    if (n <= 0 || n !== Math.floor(n)) {
      throw new Error("expected a positive non-zero integer, got " + n);
    }
    idx = -1;
    m = 0;
    p = 1;
    rnd_pick = rnd_from_seed(seed);
    rnd_idx = rnd_from_seed(seed);
    collector = [];
    on_data = function(record) {

      /* thx to http://math.stackexchange.com/a/890284/168522,
      http://math.stackexchange.com/a/890285/168522
       */
      idx += 1;
      if (!(idx === 0 && headers)) {
        m += 1;
        if (m <= n) {
          collector.push(record);
        } else {
          p = n / m;
          if (rnd_pick() < p) {
            collector[get_random_integer(rnd_idx, 0, n - 1)] = record;
          }
        }
      }
      return this.emit('data', record);
    };
    on_end = function() {
      result_handler(null, collector);
      return this.emit('end');
    };
    return ES.through(on_data, on_end);
  };

  this.$collect = function(handler) {
    var collector;
    if (handler == null) {
      handler = null;
    }
    collector = [];
    return this.remit((function(_this) {
      return function(record, send, end) {
        if (record != null) {
          collector.push(record);
        }
        if (end != null) {
          if (handler != null) {
            handler(null, collector);
          } else {
            send(collector);
          }
          return end();
        }
      };
    })(this));
  };

  this.$ngrams = function(min, max) {

    /* Given two length boundaries `min` and `max`, return a transformer that, when applied to any piece of
    data that has a `Array`-ish accessor model (i.e. a `length` attribute and numeric elements), will
    pass on a list `[ record, ngrams, ]`, where `record` is the original data and `ngrams` is a list of
    all slices of the record with adjacent elements ranging from length `min` to length `max`.
     */
    return this.remit((function(_this) {
      return function(record, send) {
        if (record != null) {
          return send([record, _this.ngrams(record, min, max)]);
        }
      };
    })(this));
  };

  this.ngrams = function(x, min, max) {
    var R, count, d, idx_0, last_idx, stop, _i, _j, _ref;
    if ((count = x.length) == null) {
      throw new Error("unable to find ngrams for value of type " + (TYPES.type_of(x)));
    }
    R = [];
    last_idx = count - 1;
    if (count >= min) {
      for (d = _i = min; min <= max ? _i <= max : _i >= max; d = min <= max ? ++_i : --_i) {
        if ((stop = count - d) >= 0) {
          for (idx_0 = _j = 0, _ref = count - d; 0 <= _ref ? _j <= _ref : _j >= _ref; idx_0 = 0 <= _ref ? ++_j : --_j) {
            R.push(x.slice(idx_0, idx_0 + d));
          }
        }
      }
    }
    return R;
  };

  this.$signal_end = function(signal) {
    var on_data, on_end;
    if (signal == null) {
      signal = this.eos;
    }

    /* Given an optional `signal` (which defaults to `null`), return a stream transformer that emits
    `signal` as last value in the stream. Observe that whatever value you choose for `signal`, that value
    should be gracefully handled by any transformers that follow in the pipe.
     */
    on_data = null;
    on_end = function() {
      this.emit('data', signal);
      return this.emit('end');
    };
    return ES.through(on_data, on_end);
  };

  this.$on_end = function(method) {
    return this.$_on_end(method, false);
  };

  this.$catch_end = function(method) {
    return this.$_on_end(method, true);
  };

  this.$_on_end = function(method, do_catch) {
    if (do_catch == null) {
      do_catch = false;
    }
    return this.remit(function(data, send, end) {
      if (data != null) {
        send(data);
      }
      if (end != null) {
        method(send, end);
        if (!do_catch) {
          return end();
        }
      }
    });
  };

  this.$on_start = function(method) {
    var is_first;
    is_first = true;
    return this.remit(function(data, send) {
      if (is_first) {
        method(send);
      }
      is_first = false;
      return send(data);
    });
  };

  this.$value_from_key = function(x) {
    return this.remit(function(key, send) {
      if (x != null) {
        return send(x[key]);
      }
    });
  };

  this.$read_values = function(x) {

    /* TAINT produces an intermediate list of object keys */
    return this.$chain(this.read_list(Object.keys(x)), this.$value_from_key(x));
  };

  this.$show = function(badge) {
    var show;
    if (badge == null) {
      badge = null;
    }
    if (badge != null) {
      show = TRM.get_logger('info', badge);
    } else {
      show = info;
    }
    return this.remit((function(_this) {
      return function(record, send) {
        show(rpr(record));
        return send(record);
      };
    })(this));
  };

  this.$count = function(handler) {

    /* TAINT make signal configurable */

    /* Given an optional `handler`, issue a count of records upon stream completion.
    
    When a handler is given, then it is called the NodeJS way as `handler null, count`; all records are passed
    through untouched and may be consumed by downstream transformers.
    
    Conversely, when no handler is given, then `$count` acts as an aggregator: all records are silently
    tossed, and the only item left in the pipe is the count.
    
    In any event, if a PipeDreams End-Of-Stream value is detected in the pipe, it is passed through and not
    counted; when `$count` is called without a handler, then the EOS will be sent *after* the count.
     */
    var count, eos, on_data, on_end, received_eos;
    eos = this.eos;
    received_eos = false;
    count = 0;
    if (handler != null) {
      on_data = function(record) {
        if (record === eos) {
          return received_eos = true;
        } else {
          count += 1;
          return this.emit('data', record);
        }
      };
      on_end = function() {
        handler(null, count);
        if (received_eos) {
          this.emit('data', eos);
        }
        return this.emit('end');
      };
    } else {
      on_data = function(record) {
        if (record === eos) {
          return received_eos = true;
        } else {
          return count += 1;
        }
      };
      on_end = function() {
        this.emit('data', count);
        if (received_eos) {
          this.emit('data', eos);
        }
        return this.emit('end');
      };
    }
    return ES.through(on_data, on_end);
  };

  this.$parse_csv = function(options) {
    var delimiter, field_names, headers, qualifier, _ref, _ref1, _ref2;
    field_names = null;
    if (options == null) {
      options = {};
    }
    headers = (_ref = options['headers']) != null ? _ref : true;
    delimiter = (_ref1 = options['delimiter']) != null ? _ref1 : ',';
    qualifier = (_ref2 = options['qualifier']) != null ? _ref2 : '"';
    return this.remit((function(_this) {
      return function(record, send) {
        var idx, value, values, _i, _len;
        if (record != null) {
          values = (S(record)).parseCSV(delimiter, qualifier, '\\');
          if (headers) {
            if (field_names === null) {
              return field_names = values;
            } else {
              record = {};
              for (idx = _i = 0, _len = values.length; _i < _len; idx = ++_i) {
                value = values[idx];
                record[field_names[idx]] = value;
              }
              return send(record);
            }
          } else {
            return send(values);
          }
        }
      };
    })(this));
  };

  this.$as_pods = function() {
    var field_names, record_idx;
    record_idx = -1;
    field_names = null;
    return this.remit((function(_this) {
      return function(record, send) {
        var R, field_idx, field_name, field_value, _i, _len;
        if (record != null) {
          if ((record_idx += 1) === 0) {
            return field_names = record;
          } else {
            R = {};
            for (field_idx = _i = 0, _len = record.length; _i < _len; field_idx = ++_i) {
              field_value = record[field_idx];
              field_name = field_names[field_idx];
              R[field_name] = field_value;
            }
            return send(R);
          }
        }
      };
    })(this));
  };

  this.$delete_prefix = function(prefix) {
    var starts_with;
    if (njs_util.isRegExp(prefix)) {
      starts_with = function(text, prefix) {
        return prefix.test(text);
      };
    } else {
      starts_with = function(text, prefix) {
        return (text.lastIndexOf(prefix, 0)) === 0;
      };
    }
    return this.remit((function(_this) {
      return function(record, send) {
        var field_value, new_field_name, old_field_name;
        if (record != null) {
          for (old_field_name in record) {
            field_value = record[old_field_name];
            if (!starts_with(old_field_name, prefix)) {
              continue;
            }
            new_field_name = old_field_name.replace(prefix, '');
            if (new_field_name.length === 0) {
              continue;
            }

            /* TAINT should throw error */
            if (record[new_field_name] != null) {
              continue;
            }
            record[new_field_name] = field_value;
            delete record[old_field_name];
          }
          return send(record);
        }
      };
    })(this));
  };

  this.$dasherize_field_names = function() {
    return this.remit((function(_this) {
      return function(record, send) {
        var new_field_name, old_field_name;
        if (record != null) {
          for (old_field_name in record) {
            new_field_name = old_field_name.replace(/_/g, '-');
            if (new_field_name === old_field_name) {
              continue;
            }
            _this._rename(record, old_field_name, new_field_name);
          }
          return send(record);
        }
      };
    })(this));
  };

  this._rename = function(record, old_field_name, new_field_name) {
    this._copy(record, old_field_name, new_field_name, 'rename');
    delete record[old_field_name];
    return record;
  };

  this._copy = function(record, old_field_name, new_field_name, action) {
    var error;
    if (record[old_field_name] === void 0) {
      error = new Error("when trying to " + action + " field " + (rpr(old_field_name)) + " to " + (rpr(new_field_name)) + "\nfound that there is no field " + (rpr(old_field_name)) + " in\n" + (rpr(record)));
      error['code'] = 'no such field';
      throw error;
    }
    if (record[new_field_name] !== void 0) {
      throw new Error("when trying to " + action + " field " + (rpr(old_field_name)) + " to " + (rpr(new_field_name)) + "\nfound that field " + (rpr(new_field_name)) + " already present in\n" + (rpr(record)));
      error['code'] = 'duplicate field';
      throw error;
    }
    record[new_field_name] = record[old_field_name];
    return record;
  };

  this.$rename = function(old_field_name, new_field_name) {
    return this.remit((function(_this) {
      return function(record, send) {
        if (record != null) {
          return send(_this._rename(record, old_field_name, new_field_name));
        }
      };
    })(this));
  };

  this.$copy = function(old_field_name, new_field_name) {
    return this.remit((function(_this) {
      return function(record, send) {
        if (record != null) {
          return send(_this._copy(record, old_field_name, new_field_name, 'copy'));
        }
      };
    })(this));
  };

  this.$set = function(field_name, field_value) {
    return this.remit((function(_this) {
      return function(record, send) {
        if (record != null) {
          record[field_name] = field_value;
          return send(record);
        }
      };
    })(this));
  };

  this.$pick = function() {
    var fallback, field_names, options, send_list, _i;
    field_names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
    if (TYPES.isa_text(options)) {
      options = {};
      field_names.push(options);
    }
    if (!(field_names.length > 0)) {
      throw new Error("need at least one field name");
    }
    fallback = options['fallback'];
    send_list = field_names.length > 1;
    return this.remit((function(_this) {
      return function(record, send) {
        var Z, field_name, value, _j, _len;
        if (record != null) {
          Z = [];
          for (_j = 0, _len = field_names.length; _j < _len; _j++) {
            field_name = field_names[_j];
            value = record[field_name];
            if (value === void 0) {
              if (fallback === void 0) {
                return send.error(new Error("field " + (rpr(field_name)) + " not defined in " + (rpr(record))));
              }
              value = fallback;
            }
            Z.push(value);
          }
          return send(send_list ? Z : Z[0]);
        }
      };
    })(this));
  };

  this.$insert = function() {
    var values;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.remit((function(_this) {
      return function(record, send) {
        var idx, _i, _ref;
        for (idx = _i = _ref = values.length - 1; _i >= 0; idx = _i += -1) {
          record.unshift(values[idx]);
        }
        return send(record);
      };
    })(this));
  };

  this.$transform = function(transformer) {
    return this.remit((function(_this) {
      return function(record, send) {
        var new_record;
        if ((new_record = transformer(record)) !== void 0) {
          return send(new_record);
        }
      };
    })(this));
  };

  this.$transform_field = function(field_name, transformer) {

    /* Given a `field_name` and a `transformer`, (return a pipeable function with this behavior:) apply
    `transformer` to each record as `record[ field_name ] = transformer record[ field_name ]`. However,
    when `transformer` returns `undefined`, then the field is removed from record (using `Array.splice` if
    `record` is a list). If `record[ field_name ]` happens to be undefined *before* `transformer` is called,
    and error is passed on instead.
     */
    return this.remit((function(_this) {
      return function(record, send) {
        var new_value, value;
        value = record[field_name];
        if (value === void 0) {
          return send.error(new Error("field " + (rpr(field_name)) + " not defined in " + (rpr(record))));
        }
        if ((new_value = transformer(value)) === void 0) {
          if (TYPES.isa_list(record)) {
            record.splice(field_name, 1);
          } else {
            delete record[field_name];
          }
        } else {
          record[field_name] = new_value;
        }
        return send(record);
      };
    })(this));
  };

  get_random_integer = function(rnd, min, max) {
    return (Math.floor(rnd() * (max + 1 - min))) + min;
  };

  rnd_from_seed = function(seed) {
    if (seed != null) {
      return (require('coffeenode-bitsnpieces')).get_rnd(seed);
    } else {
      return Math.random;
    }
  };

}).call(this);
