// Generated by CoffeeScript 1.7.1
(function() {
  var ES, S, TEXT, TRM, alert, badge, debug, echo, get_random_integer, help, info, log, njs_util, rainbow, rnd_from_seed, rpr, urge, warn, whisper;

  njs_util = require('util');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'PIPEDREAMS/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);


  /* https://github.com/dominictarr/event-stream */

  ES = require('event-stream');


  /* http://c2fo.github.io/fast-csv/index.html, https://github.com/C2FO/fast-csv */

  S = require('string');

  this.create_readstream = require('./create-readstream');

  this.$ = ES.map.bind(ES);

  this.$split = ES.split.bind(ES);

  this.$skip_empty = function() {
    return this.$((function(_this) {
      return function(record, handler) {
        if (record.length === 0) {
          return handler();
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$skip_after = function(limit) {
    var count;
    if (limit == null) {
      limit = 1;
    }
    count = 0;
    return this.$((function(_this) {
      return function(record, handler) {
        if (count > limit) {
          return handler();
        }
        count += 1;
        return handler(null, record);
      };
    })(this));
  };

  this.$sample = function(p, options) {
    var count, headers, rnd, seed, _ref, _ref1;
    if (p == null) {
      p = 0.5;
    }

    /* Given a `0 <= p <= 1`, interpret `p` as the *p*robability to *p*ick a given record and otherwise toss
    it, so that `$sample 1` will keep all records, `$sample 0` will toss all records, and
    `$sample 0.5` (the default) will toss every other record.
    
    You can pipe several `$sample()` calls, reducing the data stream to 50% with each step. If you know
    your data set has, say, 1000 records, you can cut down to a random sample of 10 by piping the result of
    calling `$sample 1 / 1000 * 10` (or, of course, `$sample 0.01`).
    
    Tests have shown that a data file with 3'722'578 records (which didn't even fit into memory when parsed)
    could be perused in a matter of seconds with `$sample 1 / 1e4`, delivering a sample of around 370
    records. Because these records are randomly selected and because the process is so immensely sped up, it
    becomes possible to develop regular data processing as well as coping strategies for data-overload
    symptoms with much more ease as compared to a situation where small but realistic data sets are not
    available or have to be produced in an ad-hoc, non-random manner.
    
    **Parsing CVS**: There is a slight complication when your data is in a CXV-like format: in that case,
    there is, with `0 < p < 1`, a certain chance that the *first* line of a file is tossed, but some
    subsequent lines are kept. If you start to transform the text line into objects with named values later in
    the pipe (which makessense, because you will typically want to thin out largeish streams as early on as
    feasible), the first line kept will be mis-interpreted as a header line (which must come first in CVS
    files) and cause all subsequent records to become weirdly malformed. To safeguard against this, use
    `$sample p, headers: true` (JS: `$sample( p, { headers: true } )`) in your code.
    
    **Predictable Samples**: Sometimes it is important to have randomly selected data where samples are
    constant across multiple runs (e.g. because once you have seen that a certain record appears on the screen
    log, you are certain it will be in the database, so you can write a snippet to search for this specific
    one). In such a case, use `$sample p, seed: 1234` with a non-zero number of your choice); you will then
    get the exact same sample whenever you re-run your piping application with the same stream, the same seed,
    and the same delta. An interesting property of the predictable sample is that a sample with a smaller `p`
    will always be a subset of a sample with a bigger `p` and vice versa (provided seed and delta were
    constant).
     */
    if (!((0 <= p && p <= 1))) {
      throw new Error("need a probability between 0 and 1, got rpr " + p);
    }
    headers = (_ref = options != null ? options['headers'] : void 0) != null ? _ref : false;
    seed = (_ref1 = options != null ? options['seed'] : void 0) != null ? _ref1 : null;
    count = 0;
    rnd = rnd_from_seed(seed);
    return this.$((function(_this) {
      return function(record, handler) {
        count += 1;
        if ((count === 1 && headers) || rnd() < p) {
          return handler(null, record);
        }
        return handler();
      };
    })(this));
  };

  this.$collect = function(input_stream, n, result_handler) {
    var collector;
    collector = [];
    input_stream.on('end', (function(_this) {
      return function() {
        if (collector.length > 0) {
          result_handler(null, collector);
        }
        return result_handler(null, null);
      };
    })(this));
    return this.$(function(record, handler) {
      collector.push(record);
      if (collector.length >= n) {
        result_handler(null, collector);
        collector = [];
      }
      return handler(null, collector);
    });
  };

  this.$collect_sample = function(input_stream, n, options, result_handler) {

    /* Given an `input_stream`, a positive integer number `n`, (facultatively) options, and a `handler`, try
    to assemble a representative sample with up to `n` records from the stream. When the stream has ended,
    the handler is called once with (a `null` error argument and) a list of records.
    
    Similarly to `PIPEDREAMS.$sample`, it is possible to pass in a `headers: true` option to make sure the
    headers line of a CVS file is not collected. Also similarly, a `seed: 1234` argument can be used to
    ensure that the sample is arbitrary but constant for the same stream and the same seed.
    
    Observe that while `$sample` does thin out the stream, `$collect_sample` will never add anything to or
    omit anything from the stream; in that respect, it is rather more similar to `$collect`.
    
    The (simple) algorithm this method uses to arrive at a representative, fixed-size sample from a collection
    of unknown size has been kindly provided by two guys on
    [Math StackExchange](http://math.stackexchange.com/q/890272/168522).
     */
    var arity, collector, headers, idx, m, p, rnd_idx, rnd_pick, seed, _ref, _ref1;
    switch (arity = arguments.length) {
      case 3:
        result_handler = options;
        headers = false;
        seed = null;
        break;
      case 4:
        headers = (_ref = options['headers']) != null ? _ref : false;
        seed = (_ref1 = options['seed']) != null ? _ref1 : null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    if (n <= 0 || n !== Math.floor(n)) {
      throw new Error("expected a positive non-zero integer, got " + n);
    }
    idx = -1;
    m = 0;
    p = 1;
    rnd_pick = rnd_from_seed(seed);
    rnd_idx = rnd_from_seed(seed);
    collector = [];
    input_stream.once('end', (function(_this) {
      return function() {
        return result_handler(null, collector);
      };
    })(this));
    return this.$((function(_this) {
      return function(record, handler) {

        /* thx to http://math.stackexchange.com/a/890284/168522,
        http://math.stackexchange.com/a/890285/168522
         */
        idx += 1;
        if (!(idx === 0 && headers)) {
          m += 1;
          if (m <= n) {
            collector.push(record);
          } else {
            p = n / m;
            if (rnd_pick() >= p) {
              collector[get_random_integer(rnd_idx, 0, n - 1)] = record;
            }
          }
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$show_and_quit = function() {
    return this.$((function(_this) {
      return function(record, handler) {
        info(rpr(record));
        warn('aborting from `TRANSFORMERS.show_and_quit`');
        setImmediate(function() {
          return process.exit();
        });
        return handler(null, record);
      };
    })(this));
  };

  this.$show_table = function(input_stream) {

    /* TAINT may introduce a memory leak. */
    var EASYTABLE, records;
    EASYTABLE = require('easy-table');
    records = [];
    input_stream.once('end', (function(_this) {
      return function() {
        return echo(EASYTABLE.printArray(records));
      };
    })(this));
    return this.$((function(_this) {
      return function(record, handler) {
        records.push(record);
        return handler(null, record);
      };
    })(this));
  };

  this.$show = function() {
    return this.$((function(_this) {
      return function(record, handler) {
        info(rpr(record));
        return handler(null, record);
      };
    })(this));
  };

  this.$show_sample = function(input_stream) {

    /* TAINT may introduce a memory leak. */
    var records;
    records = [];
    input_stream.once('end', (function(_this) {
      return function() {
        whisper('©5r0', "displaying random record out of " + records.length);
        return debug('©5r0', rpr(records[Math.floor(Math.random() * records.length)]));
      };
    })(this));
    return this.$((function(_this) {
      return function(record, handler) {
        records.push(record);
        return handler(null, record);
      };
    })(this));
  };

  this.$count = function(input_stream, title) {
    var count;
    count = 0;
    input_stream.on('end', function() {
      return urge((title != null ? title : 'Count') + ':', count);
    });
    return this.$((function(_this) {
      return function(record, handler) {
        count += 1;
        return handler(null, record);
      };
    })(this));
  };

  this.$parse_csv = function() {
    var field_names;
    field_names = null;
    return this.$((function(_this) {
      return function(record, handler) {
        var idx, value, values, _i, _len;
        values = (S(record)).parseCSV(',', '"', '\\');
        if (field_names === null) {
          field_names = values;
          return handler();
        }
        record = {};
        for (idx = _i = 0, _len = values.length; _i < _len; idx = ++_i) {
          value = values[idx];
          record[field_names[idx]] = value;
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$as_pods = function() {
    var field_names, record_idx;
    record_idx = -1;
    field_names = null;
    return this.$((function(_this) {
      return function(record, handler) {
        var R, field_idx, field_name, field_value, _i, _len;
        if ((record_idx += 1) === 0) {
          field_names = record;
          return;
        }
        R = {};
        for (field_idx = _i = 0, _len = record.length; _i < _len; field_idx = ++_i) {
          field_value = record[field_idx];
          field_name = field_names[field_idx];
          R[field_name] = field_value;
        }
        return handler(null, R);
      };
    })(this));
  };

  this.$delete_prefix = function(prefix) {
    var starts_with;
    if (njs_util.isRegExp(prefix)) {
      starts_with = function(text, prefix) {
        return prefix.test(text);
      };
    } else {
      starts_with = function(text, prefix) {
        return (text.lastIndexOf(prefix, 0)) === 0;
      };
    }
    return this.$((function(_this) {
      return function(record, handler) {
        var field_value, new_field_name, old_field_name;
        for (old_field_name in record) {
          field_value = record[old_field_name];
          if (!starts_with(old_field_name, prefix)) {
            continue;
          }
          new_field_name = old_field_name.replace(prefix, '');
          if (new_field_name.length === 0) {
            continue;
          }

          /* TAINT should throw error */
          if (record[new_field_name] != null) {
            continue;
          }
          record[new_field_name] = field_value;
          delete record[old_field_name];
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$dasherize_field_names = function() {
    return this.$((function(_this) {
      return function(record, handler) {
        var new_field_name, old_field_name;
        for (old_field_name in record) {
          new_field_name = old_field_name.replace(/_/g, '-');
          if (new_field_name === old_field_name) {
            continue;
          }
          _this._rename(record, old_field_name, new_field_name);
        }
        return handler(null, record);
      };
    })(this));
  };

  this._rename = function(record, old_field_name, new_field_name) {
    this._copy(record, old_field_name, new_field_name, 'rename');
    delete record[old_field_name];
    return record;
  };

  this._copy = function(record, old_field_name, new_field_name, action) {
    var error;
    if (record[old_field_name] === void 0) {
      error = new Error("when trying to " + action + " field " + (rpr(old_field_name)) + " to " + (rpr(new_field_name)) + "\nfound that there is no field " + (rpr(old_field_name)) + " in\n" + (rpr(record)));
      error['code'] = 'no such field';
      throw error;
    }
    if (record[new_field_name] !== void 0) {
      throw new Error("when trying to " + action + " field " + (rpr(old_field_name)) + " to " + (rpr(new_field_name)) + "\nfound that field " + (rpr(new_field_name)) + " already present in\n" + (rpr(record)));
      error['code'] = 'duplicate field';
      throw error;
    }
    record[new_field_name] = record[old_field_name];
    return record;
  };

  this.$rename = function(old_field_name, new_field_name) {
    return this.$((function(_this) {
      return function(record, handler) {
        return handler(null, _this._rename(record, old_field_name, new_field_name));
      };
    })(this));
  };

  this.$copy = function(old_field_name, new_field_name) {
    return this.$((function(_this) {
      return function(record, handler) {
        return handler(null, _this._copy(record, old_field_name, new_field_name, 'copy'));
      };
    })(this));
  };

  this.$set = function(field_name, field_value) {
    return this.$((function(_this) {
      return function(record, handler) {
        record[field_name] = field_value;
        return handler(null, record);
      };
    })(this));
  };

  get_random_integer = function(rnd, min, max) {
    return (Math.floor(rnd() * (max + 1 - min))) + min;
  };

  rnd_from_seed = function(seed) {
    if (seed != null) {
      return (require('coffeenode-bitsnpieces')).get_rnd(seed);
    } else {
      return Math.random;
    }
  };

}).call(this);
