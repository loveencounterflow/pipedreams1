// Generated by CoffeeScript 1.7.1
(function() {
  var ProgressBar, after, njs_fs;

  njs_fs = require('fs');


  /* https://github.com/visionmedia/node-progress */

  ProgressBar = require('progress');


  /* https://github.com/felixge/node-combined-stream */

  after = function(time_s, f) {
    return setTimeout(f, time_s * 1000);
  };

  this.StringReader = require('./pronto_lib_streams_stringreader.js');

  this.create_readstream = function(route, label) {

    /* Create and return a new instance of a read stream form a single route or a list of routes. In the
    latter case, a combined stream using [combined-stream](https://github.com/felixge/node-combined-stream) is
    constructed so that several files (presumable the result of an earlier split operation) are transparently
    read like a single, huge file.
    
    As a bonus, the module uses [node-progress](https://github.com/visionmedia/node-progress) to display a
    progress bar for reading operations that last for more than a couple seconds.
    
    <!-- As a second bonus, the module uses CoffeeNode's `TRM.listen_to_keys` method to implement a `ctrl-C,
    ctrl-C`-style abort shortcut with an informative message displayed when `ctrl-C` has been hit by the user
    once; this is to prevent longish read operations to be inadvertantly terminated.-->
     */
    var CombinedStream, R, partial_route, routes, _i, _len;
    if (Array.isArray(route)) {
      routes = route;

      /* https://github.com/felixge/node-combined-stream */
      CombinedStream = require('combined-stream');
      R = CombinedStream.create();
      for (_i = 0, _len = routes.length; _i < _len; _i++) {
        partial_route = routes[_i];
        R.append(njs_fs.createReadStream(partial_route));
      }
    } else {
      R = njs_fs.createReadStream(route);
    }
    return this.pimp_readstream(R, this._get_filesize(route), label);
  };

  this.create_readstream_from_text = function(text, autoresume) {
    var R;
    if (autoresume == null) {
      autoresume = false;
    }

    /* Given a `text`, return a paused stream that will, when resumed, emit the string contents. When a
    second, truthy argument is given, the stream will be auto-resumed, but only on next tick, so there's time
    to attach listeners to the stream before it starts emitting. The default is to return a paused stream so
    you get a chance to pass the stream around to other consumers. — Consider to write
    
        P.resume P.create_readstream_from_text 'helo'
    
    instead of passing `true` for better readability.
     */
    R = new this.StringReader(text);
    if (autoresume) {
      setImmediate(function() {
        return R.resume();
      });
    }
    return R;
  };

  this.pimp_readstream = function(stream, size, label) {
    var bar, bar_is_shown, count_collector, format, is_first_call, options, timer;
    count_collector = 0;
    bar_is_shown = false;
    is_first_call = true;
    format = "[:bar] :percent | :current / " + size + " | +:elapseds -:etas " + (label != null ? label : '');
    options = {
      width: 50,
      total: size,
      complete: '#',
      incomplete: '—'
    };
    stream.on('data', function(data) {
      var is_buffer;
      is_buffer = Buffer.isBuffer(data);
      if (is_buffer) {
        count_collector += data.length;
      } else {
        count_collector += 1;
      }
      if (bar_is_shown) {
        bar.tick(is_first_call ? count_collector : (is_buffer ? data.length : 1));
        return is_first_call = false;
      }
    });
    bar = new ProgressBar(format, options);
    timer = after(3, function() {
      return bar_is_shown = true;
    });
    stream.on('end', function() {
      return clearTimeout(timer);
    });
    return stream;
  };

  this._get_filesize = function(route) {

    /* Helper to compute filesize from a single route or a list of routes. */
    var R, partial_route, _i, _len;
    if (!Array.isArray(route)) {
      return (njs_fs.statSync(route)).size;
    }
    R = 0;
    for (_i = 0, _len = route.length; _i < _len; _i++) {
      partial_route = route[_i];
      R += this._get_filesize(partial_route);
    }
    return R;
  };

}).call(this);
